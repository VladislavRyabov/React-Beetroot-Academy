{"ast":null,"code":"\"use strict\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.jsx\nvar src_exports = {};\n__export(src_exports, {\n  default: () => src_default\n});\nmodule.exports = __toCommonJS(src_exports);\nvar import_react = require(\"react\");\nvar import_prop_types = __toESM(require(\"prop-types\"));\nvar DefaultCanvasSize = 16;\nvar linkElements = [];\nvar drawAlert = (context, _ref) => {\n  let {\n    fillColor,\n    text,\n    textColor,\n    canvasSize\n  } = _ref;\n  const Padding = canvasSize / 5;\n  context.font = `bold ${canvasSize - Padding * 2}px arial`;\n  const w = Math.min(\n  // Take the text with if it's smaller than available space (eg: '2')\n  context.measureText(text).width,\n  // Or take the maximum size we'll force our text to fit in anyway (eg: '1000000')\n  canvasSize - Padding) + Padding;\n  const x = canvasSize - w;\n  const y = canvasSize / 2 - Padding;\n  const h = Padding + canvasSize / 2;\n  const r = Math.min(w / 2, h / 2);\n  context.beginPath();\n  context.moveTo(x + r, y);\n  context.arcTo(x + w, y, x + w, y + h, r);\n  context.arcTo(x + w, y + h, x, y + h, r);\n  context.arcTo(x, y + h, x, y, r);\n  context.arcTo(x, y, x + w, y, r);\n  context.closePath();\n  context.fillStyle = fillColor;\n  context.fill();\n  context.fillStyle = textColor;\n  context.textBaseline = \"bottom\";\n  context.textAlign = \"right\";\n  context.fillText(text, canvasSize - Padding / 2, canvasSize,\n  // This will prevent the text from going outside the favicon, instead it'll squeeze his with to fit in\n  canvasSize - Padding);\n};\nvar drawIcon = _ref2 => {\n  let {\n    alertCount,\n    alertFillColor,\n    alertTextColor,\n    callback,\n    renderOverlay,\n    url: src,\n    canvasSize\n  } = _ref2;\n  const img = document.createElement(\"img\");\n  img.crossOrigin = \"Anonymous\";\n  img.onload = function () {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = canvasSize;\n    canvas.height = canvasSize;\n    const context = canvas.getContext(\"2d\");\n    context.clearRect(0, 0, img.width, img.height);\n    context.drawImage(img, 0, 0, canvas.width, canvas.height);\n    if (alertCount) {\n      drawAlert(context, {\n        fillColor: alertFillColor,\n        textColor: alertTextColor,\n        text: alertCount,\n        canvasSize\n      });\n    }\n    if (renderOverlay) {\n      renderOverlay(canvas, context);\n    }\n    callback(context.canvas.toDataURL());\n  };\n  img.src = src;\n};\nvar updateHtmlIconLink = keepIconLink => {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n  if (linkElements.length === 0) {\n    var head = document.getElementsByTagName(\"head\")[0];\n    const linkEl = document.createElement(\"link\");\n    linkEl.type = \"image/x-icon\";\n    linkEl.rel = \"icon\";\n    const linkApple = document.createElement(\"link\");\n    linkApple.rel = \"apple-touch-icon\";\n    linkElements.push(linkEl, linkApple);\n    var links = head.getElementsByTagName(\"link\");\n    for (var i = links.length; --i >= 0;) {\n      if (/\\bicon\\b/i.test(links[i].getAttribute(\"rel\")) && !keepIconLink(links[i])) {\n        head.removeChild(links[i]);\n      }\n    }\n    linkElements.forEach(el => head.appendChild(el));\n  }\n};\nvar Favicon = _ref3 => {\n  let {\n    iconSize,\n    alertCount,\n    alertFillColor,\n    alertTextColor,\n    animated,\n    animationDelay,\n    keepIconLink,\n    renderOverlay,\n    url\n  } = _ref3;\n  const animationIndex = (0, import_react.useRef)(0);\n  const animationTickIntervalId = (0, import_react.useRef)(null);\n  const [, updateState] = (0, import_react.useState)();\n  const forceUpdate = (0, import_react.useCallback)(() => updateState({}), []);\n  const onAnimationTick = (0, import_react.useCallback)(() => {\n    updateHtmlIconLink(keepIconLink);\n    animationIndex.current = (animationIndex.current + 1) % url.length;\n    forceUpdate();\n  }, [forceUpdate, keepIconLink, url]);\n  (0, import_react.useEffect)(() => {\n    onAnimationTick();\n  }, [onAnimationTick]);\n  const isAnimated = url instanceof Array && animated;\n  (0, import_react.useEffect)(() => {\n    if (isAnimated) {\n      if (!animationTickIntervalId.current) {\n        const intervalId = setInterval(onAnimationTick, animationDelay);\n        animationTickIntervalId.current = intervalId;\n      }\n    } else {\n      if (animationTickIntervalId.current) {\n        clearInterval(animationTickIntervalId.current);\n        animationTickIntervalId.current = null;\n        updateHtmlIconLink(keepIconLink);\n      }\n    }\n  }, [animationDelay, isAnimated, keepIconLink, onAnimationTick, url]);\n  const currentUrl = isAnimated ? url[animationIndex.current] : url instanceof Array ? url[0] : url;\n  if (alertCount || renderOverlay) {\n    drawIcon({\n      alertCount,\n      alertFillColor,\n      alertTextColor,\n      callback: url2 => {\n        linkElements.forEach(el => el.href = url2);\n      },\n      renderOverlay,\n      url: currentUrl,\n      canvasSize: iconSize\n    });\n  } else {\n    linkElements.forEach(el => el.href = currentUrl);\n  }\n  return null;\n};\nFavicon.defaultProps = {\n  iconSize: DefaultCanvasSize,\n  alertCount: null,\n  alertFillColor: \"red\",\n  alertTextColor: \"white\",\n  animated: true,\n  animationDelay: 500,\n  keepIconLink: () => false,\n  renderOverlay: null,\n  url: null\n};\nFavicon.propTypes = {\n  iconSize: import_prop_types.default.number,\n  alertCount: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),\n  alertFillColor: import_prop_types.default.string,\n  alertTextColor: import_prop_types.default.string,\n  animated: import_prop_types.default.bool,\n  animationDelay: import_prop_types.default.number,\n  keepIconLink: import_prop_types.default.func,\n  renderOverlay: import_prop_types.default.func,\n  url: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string), import_prop_types.default.string]).isRequired\n};\nvar src_default = Favicon;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {});\nmodule.exports = module.exports.default;","map":{"version":3,"mappings":"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","names":["__export","default","module","require","__toESM","DefaultCanvasSize","linkElements","drawAlert","context","fillColor","text","textColor","canvasSize","Padding","font","w","Math","min","measureText","width","x","y","h","r","beginPath","moveTo","arcTo","closePath","fillStyle","fill","textBaseline","textAlign","fillText","drawIcon","alertCount","alertFillColor","alertTextColor","callback","renderOverlay","url","src","img","document","createElement","crossOrigin","onload","canvas","height","getContext","clearRect","drawImage","toDataURL","updateHtmlIconLink","keepIconLink","length","head","getElementsByTagName","linkEl","type","rel","linkApple","push","links","i","test","getAttribute","removeChild","forEach","el","appendChild","Favicon","iconSize","animated","animationDelay","animationIndex","import_react","animationTickIntervalId","updateState","forceUpdate","onAnimationTick","current","isAnimated","Array","intervalId","setInterval","clearInterval","currentUrl","href","defaultProps","propTypes","import_prop_types","number","oneOfType","string","bool","func","arrayOf","isRequired","src_default"],"sources":["/Users/user/Documents/Beetroot_Academy/React/React-2/front/node_modules/react-favicon/src/index.jsx"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react'\nimport PropTypes from 'prop-types'\n\nconst DefaultCanvasSize = 16\nconst linkElements = []\n\nconst drawAlert = (context, { fillColor, text, textColor, canvasSize }) => {\n  // Allow same looking padding over differents iconSizes\n  const Padding = canvasSize / 5\n  // Allow readable text across differnts iconSizes\n  context.font = `bold ${canvasSize - Padding * 2}px arial`\n\n  const w =\n    Math.min(\n      // Take the text with if it's smaller than available space (eg: '2')\n      context.measureText(text).width,\n      // Or take the maximum size we'll force our text to fit in anyway (eg: '1000000')\n      canvasSize - Padding\n    ) + Padding\n\n  const x = canvasSize - w\n  const y = canvasSize / 2 - Padding\n  const h = Padding + canvasSize / 2\n  const r = Math.min(w / 2, h / 2)\n\n  context.beginPath()\n  context.moveTo(x + r, y)\n  context.arcTo(x + w, y, x + w, y + h, r)\n  context.arcTo(x + w, y + h, x, y + h, r)\n  context.arcTo(x, y + h, x, y, r)\n  context.arcTo(x, y, x + w, y, r)\n  context.closePath()\n  context.fillStyle = fillColor\n  context.fill()\n  context.fillStyle = textColor\n  context.textBaseline = 'bottom'\n  context.textAlign = 'right'\n  context.fillText(\n    text,\n    canvasSize - Padding / 2,\n    canvasSize,\n    // This will prevent the text from going outside the favicon, instead it'll squeeze his with to fit in\n    canvasSize - Padding\n  )\n}\n\nconst drawIcon = ({\n  alertCount,\n  alertFillColor,\n  alertTextColor,\n  callback,\n  renderOverlay,\n  url: src,\n  canvasSize,\n}) => {\n  const img = document.createElement('img')\n  img.crossOrigin = 'Anonymous'\n  img.onload = function () {\n    const canvas = document.createElement('canvas')\n    canvas.width = canvasSize\n    canvas.height = canvasSize\n\n    const context = canvas.getContext('2d')\n    context.clearRect(0, 0, img.width, img.height)\n    context.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n    if (alertCount) {\n      drawAlert(context, {\n        fillColor: alertFillColor,\n        textColor: alertTextColor,\n        text: alertCount,\n        canvasSize,\n      })\n    }\n\n    if (renderOverlay) {\n      renderOverlay(canvas, context)\n    }\n    callback(context.canvas.toDataURL())\n  }\n  img.src = src\n}\n\nconst updateHtmlIconLink = (keepIconLink) => {\n  if (typeof document === 'undefined') {\n    return\n  }\n\n  if (linkElements.length === 0) {\n    var head = document.getElementsByTagName('head')[0]\n\n    const linkEl = document.createElement('link')\n    linkEl.type = 'image/x-icon'\n    linkEl.rel = 'icon'\n\n    const linkApple = document.createElement('link')\n    linkApple.rel = 'apple-touch-icon'\n\n    linkElements.push(linkEl, linkApple)\n\n    // remove existing favicons\n    var links = head.getElementsByTagName('link')\n    for (var i = links.length; --i >= 0; ) {\n      if (\n        /\\bicon\\b/i.test(links[i].getAttribute('rel')) &&\n        !keepIconLink(links[i])\n      ) {\n        head.removeChild(links[i])\n      }\n    }\n\n    linkElements.forEach((el) => head.appendChild(el))\n  }\n}\n\nconst Favicon = ({\n  iconSize,\n  alertCount,\n  alertFillColor,\n  alertTextColor,\n  animated,\n  animationDelay,\n  keepIconLink,\n  renderOverlay,\n  url,\n}) => {\n  const animationIndex = useRef(0)\n  const animationTickIntervalId = useRef(null)\n\n  const [, updateState] = useState()\n  const forceUpdate = useCallback(() => updateState({}), [])\n\n  const onAnimationTick = useCallback(() => {\n    updateHtmlIconLink(keepIconLink)\n    animationIndex.current = (animationIndex.current + 1) % url.length\n    forceUpdate()\n  }, [forceUpdate, keepIconLink, url])\n\n  // Perform initial favicon update\n  useEffect(() => {\n    onAnimationTick()\n  }, [onAnimationTick])\n\n  const isAnimated = url instanceof Array && animated\n\n  useEffect(() => {\n    if (isAnimated) {\n      if (!animationTickIntervalId.current) {\n        const intervalId = setInterval(onAnimationTick, animationDelay)\n        animationTickIntervalId.current = intervalId\n      }\n    } else {\n      if (animationTickIntervalId.current) {\n        clearInterval(animationTickIntervalId.current)\n        animationTickIntervalId.current = null\n        updateHtmlIconLink(keepIconLink)\n      }\n    }\n  }, [animationDelay, isAnimated, keepIconLink, onAnimationTick, url])\n\n  const currentUrl = isAnimated\n    ? url[animationIndex.current]\n    : url instanceof Array\n    ? url[0]\n    : url\n\n  if (alertCount || renderOverlay) {\n    drawIcon({\n      alertCount,\n      alertFillColor,\n      alertTextColor,\n      callback: (url) => {\n        linkElements.forEach((el) => (el.href = url))\n      },\n      renderOverlay,\n      url: currentUrl,\n      canvasSize: iconSize,\n    })\n  } else {\n    linkElements.forEach((el) => (el.href = currentUrl))\n  }\n\n  return null\n}\n\nFavicon.defaultProps = {\n  iconSize: DefaultCanvasSize,\n  alertCount: null,\n  alertFillColor: 'red',\n  alertTextColor: 'white',\n  animated: true,\n  animationDelay: 500,\n  keepIconLink: () => false,\n  renderOverlay: null,\n  url: null,\n}\n\nFavicon.propTypes = {\n  iconSize: PropTypes.number,\n  alertCount: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  alertFillColor: PropTypes.string,\n  alertTextColor: PropTypes.string,\n  animated: PropTypes.bool,\n  animationDelay: PropTypes.number,\n  keepIconLink: PropTypes.func,\n  renderOverlay: PropTypes.func,\n  url: PropTypes.oneOfType([\n    PropTypes.arrayOf(PropTypes.string),\n    PropTypes.string,\n  ]).isRequired,\n}\n\nexport default Favicon\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}